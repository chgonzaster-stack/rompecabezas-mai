"use client";
import { useEffect, useRef, useState } from "react";
import Link from "next/link";

/* ==========================
   Datos de las imÃ¡genes
   ========================== */
const MONOS = [
 { id: "Azulin",     src: "/images/monos/Azulin.png",     nombre: "AzulÃ­n" },
  { id: "Chasca",     src: "/images/monos/Chasca.png",     nombre: "Chasca" },
  { id: "Revoltoso",  src: "/images/monos/Horacio.png",    nombre: "Revoltoso" },
  { id: "Luby",       src: "/images/monos/Luby.png",       nombre: "Luby" },
  { id: "Mateo",      src: "/images/monos/Mateo.png",      nombre: "Mateo" },
  { id: "Naty",       src: "/images/monos/Naty.png",       nombre: "Naty" },
  { id: "Rata",       src: "/images/monos/Rata.png",       nombre: "Rata" },
  { id: "Spanky",     src: "/images/monos/Spanky.png",     nombre: "Spanky" },
  { id: "Tallarin",   src: "/images/monos/Tallarin.png",   nombre: "TallarÃ­n" },
  { id: "Tammy",      src: "/images/monos/Tammy.png",      nombre: "Tammy" },
  { id: "Beky",       src: "/images/monos/Veky.png",       nombre: "Beky" },
  { id: "Zanadorio",  src: "/images/monos/Zanadorio.png",  nombre: "Zanadorio" },
];

type Tile = { id: number; imgX: number; imgY: number; empty?: boolean };

/* ==========================
   Select oscuro (custom)
   ========================== */
type Option<T extends string | number> = { value: T; label: string };

function DarkSelect<T extends string | number>({
  label,
  value,
  onChange,
  options,
  className = "",
  widthClass = "w-full",
}: {
  label?: string;
  value: T;
  onChange: (v: T) => void;
  options: Option<T>[];
  className?: string;
  widthClass?: string; // para forzar mismo ancho en ambos selects
}) {
  const [open, setOpen] = useState(false);
  const btnRef = useRef<HTMLButtonElement | null>(null);
  const popRef = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    const onClick = (e: MouseEvent) => {
      if (!btnRef.current || !popRef.current) return;
      if (btnRef.current.contains(e.target as Node)) return;
      if (popRef.current.contains(e.target as Node)) return;
      setOpen(false);
    };
    window.addEventListener("click", onClick);
    return () => window.removeEventListener("click", onClick);
  }, []);

  const active = options.find((o) => o.value === value);

  return (
    <div className={`relative ${widthClass}`}>
      {label && <label className="block text-sm opacity-80 mb-1">{label}</label>}

      <button
        ref={btnRef}
        type="button"
        onClick={() => setOpen((v) => !v)}
        className={`flex items-center justify-between rounded-lg border px-3 py-2
        bg-white/10 text-white border-white/20 hover:bg-white/15 focus:outline-none
        focus:ring-2 focus:ring-emerald-400 shadow-inner ${className}`}
      >
        <span className="truncate">{active?.label}</span>
        <svg className={`w-4 h-4 transition transform ${open ? "rotate-180" : ""}`} viewBox="0 0 20 20" fill="currentColor">
          <path fillRule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clipRule="evenodd" />
        </svg>
      </button>

      {open && (
        <div
          ref={popRef}
          className="absolute z-40 mt-2 w-full rounded-lg border bg-[#0B1220] text-white border-white/20 shadow-xl overflow-hidden"
          role="listbox"
        >
          <div className="max-h-56 overflow-auto">
            {options.map((opt) => {
              const selected = opt.value === value;
              return (
                <button
                  key={String(opt.value)}
                  type="button"
                  role="option"
                  aria-selected={selected}
                  onClick={() => {
                    onChange(opt.value);
                    setOpen(false);
                  }}
                  className={`w-full text-left px-3 py-2 hover:bg-white/10 ${
                    selected ? "bg-emerald-500/20" : ""
                  }`}
                >
                  {opt.label}
                </button>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
}

/* ==========================
   PÃ¡gina Rompecabezas
   ========================== */
export default function PuzzlePage() {
  const [monoId, setMonoId] = useState(MONOS[0].id);
  const [gridSize, setGridSize] = useState(3);
  const [tiles, setTiles] = useState<Tile[]>([]);
  const [moves, setMoves] = useState(0);
  const [solved, setSolved] = useState(false);

  const playWinSound = () => {
    const audio = new Audio("/sounds/win.wav");
    audio.play().catch(() => {});
  };

  // Construir tablero
  useEffect(() => {
    const arr: Tile[] = [];
    let id = 0;
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        arr.push({ id: id++, imgX: x, imgY: y });
      }
    }
    arr[arr.length - 1].empty = true; // hueco
    setTiles(arr);
    setMoves(0);
    setSolved(false);
  }, [monoId, gridSize]);

  const isAdjacent = (i: number, j: number) => {
    const xi = i % gridSize, yi = Math.floor(i / gridSize);
    const xj = j % gridSize, yj = Math.floor(j / gridSize);
    return Math.abs(xi - xj) + Math.abs(yi - yj) === 1;
  };

  const checkSolved = (arr: Tile[]) => arr.every((t, i) => t.id === i);

  const shuffle = () => {
    const mixed = [...tiles].sort(() => Math.random() - 0.5);
    setTiles(mixed);
    setMoves(0);
    setSolved(false);
  };

  const handleClick = (index: number) => {
    const emptyIndex = tiles.findIndex((t) => t.empty);
    if (isAdjacent(index, emptyIndex)) {
      const newTiles = [...tiles];
      [newTiles[index], newTiles[emptyIndex]] = [newTiles[emptyIndex], newTiles[index]];
      setTiles(newTiles);
      setMoves((m) => m + 1);
      if (checkSolved(newTiles)) {
        setSolved(true);
        playWinSound();
      }
    }
  };

  const currentMono = MONOS.find((m) => m.id === monoId)!;

  // opciones para los selects
  const imagenOpts: Option<string>[] = MONOS.map((m) => ({ value: m.id, label: m.nombre }));
  const sizeOpts: Option<number>[] = [3, 4, 5].map((n) => ({ value: n, label: `${n} Ã— ${n}` }));

  return (
    <main className="min-h-screen bg-gradient-to-b from-indigo-950 via-indigo-900 to-indigo-800 text-white">
      <div className="max-w-5xl mx-auto p-6">
        {/* Header */}
        <header className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-bold flex items-center gap-2">
            <img src="/images/reverso/cmm.png" className="w-8 h-8" alt="CMM" />
            Rompecabezas
          </h1>
          <nav className="flex gap-2">
            <Link href="/" className="px-3 py-1 rounded-lg bg-white/10 border border-white/20 hover:bg-white/20">
              Inicio
            </Link>
            <Link href="/memory" className="px-3 py-1 rounded-lg bg-white/10 border border-white/20 hover:bg-white/20">
              Memoria
            </Link>
            <button onClick={shuffle} className="px-3 py-1 rounded-lg bg-emerald-600 hover:bg-emerald-700">
              Mezclar
            </button>
          </nav>
        </header>

        {/* Controles (IMAGEN + TAMAÃ‘O + MOVS) */}
        <section className="grid gap-4 sm:grid-cols-3 mb-6">
          <DarkSelect
          label="Imagen"
          value={monoId}
          onChange={(v) => setMonoId(v)}
          options={imagenOpts}
          widthClass="min-w-[200px] sm:min-w-[240px]"
        />

        <DarkSelect
         label="TamaÃ±o"
         value={gridSize}
         onChange={(v) => setGridSize(v)}
         options={sizeOpts}
         widthClass="min-w-[140px] sm:min-w-[160px]"
        />
          <div className="flex flex-col justify-end">
            <div className="rounded-lg bg-white/10 border border-white/20 px-3 py-2">
              Movimientos: <b>{moves}</b>
            </div>
          </div>
        </section>

        {/* Tablero */}
        <div
          className="mx-auto bg-black/20 rounded-lg overflow-hidden"
          style={{
            display: "grid",
            gridTemplateColumns: `repeat(${gridSize}, 1fr)`,
            width: "min(92vw, 560px)",
            aspectRatio: "1",
          }}
        >
          {tiles.map((tile, i) => (
            <div
              key={i}
              onClick={() => !tile.empty && handleClick(i)}
              className={`relative ${tile.empty ? "bg-black/30" : "cursor-pointer hover:opacity-90"}`}
              style={{
                backgroundImage: tile.empty ? "none" : `url(${currentMono.src})`,
                backgroundSize: `${gridSize * 100}% ${gridSize * 100}%`,
                backgroundPosition: tile.empty
                  ? "center"
                  : `${(tile.imgX * 100) / (gridSize - 1)}% ${(tile.imgY * 100) / (gridSize - 1)}%`,
              }}
              aria-label={tile.empty ? "Hueco" : "Ficha"}
            />
          ))}
        </div>

        {/* Referencia */}
        <div className="mt-4 text-center">
          <div className="text-sm opacity-70">Referencia</div>
          <img
            src={currentMono.src}
            alt={currentMono.nombre}
            className="mx-auto mt-2 w-24 h-24 rounded-lg border border-white/20 object-contain"
          />
        </div>

        {/* Mensaje ganador */}
        {solved && (
          <div className="mt-6 p-3 rounded-lg bg-emerald-500/20 border border-emerald-400/40 text-center">
            ðŸŽ‰ Â¡Felicitaciones! Completaste el rompecabezas en <b>{moves}</b> movimientos.
          </div>
        )}
      </div>
    </main>
  );
}
